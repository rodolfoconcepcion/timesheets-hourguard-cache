<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="ClassExplorer.ClassView">
<Description>
Cache Class Explorer 1.16.3
Class contains methods that return structured classes/packages data.</Description>
<TimeCreated>63653,67019.989197</TimeCreated>

<Method name="getAllNamespacesList">
<Description>
Return list with all namespaces</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
    set resp = ##class(%ZEN.proxyObject).%New()
    set resp.namespaces = ##class(%ZEN.proxyObject).%New()
    set resp.currentNamespace = $NAMESPACE
    set result = ##class(%ResultSet).%New("%SYS.Namespace:List")
    do result.Execute()
    while (result.Next()) {
        set ns = ##class(%ZEN.proxyObject).%New()
        set ns.remote = result.Get("Remote")
        set ns.status = result.Get("Status")
        do resp.namespaces.%DispatchSetProperty(result.Get("Nsp"), ns)
    }
    return resp
]]></Implementation>
</Method>

<Method name="getClassTree">
<Description>
Returns structured class tree with all classes available in current namespace</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
    zn:$GET(namespace)'="" namespace
    set resp = ##class(%ZEN.proxyObject).%New()

    set classes = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:Summary")
    set objects = ##class(%Library.ArrayOfObjects).%New()
    set lastParts = $LB()

    set level = 1
    do objects.SetAt(resp, level)

    do classes.Execute()
    while (classes.Next()) {
        set name = classes.Data("Name")
        if ($EXTRACT(name, 1, 1) = "%") && ($NAMESPACE '= "%SYS") { continue }
        set parts = $LISTFROMSTRING(name, ".")
        set level = 1
        while ((level < $LISTLENGTH(parts)) && ($LISTGET(lastParts, level) = ("/"_$LISTGET(parts, level)))) {
            set level = level + 1
        }
        set resp = objects.GetAt(level)
        if (resp="") {
            set resp = ##class(%ZEN.proxyObject).%New()
            do objects.GetAt(level - 1).%DispatchSetProperty("/" _ $LISTGET(parts, level - 1), resp)
            do objects.SetAt(resp, level)
        }
        while ($LISTLENGTH(parts) > level) {
            set level = level + 1
            set resp = ##class(%ZEN.proxyObject).%New()
            do objects.GetAt(level - 1).%DispatchSetProperty("/" _ $LISTGET(parts, level - 1), resp)
            do objects.SetAt(resp, level)
        }
        if ($LISTLENGTH(parts) = level) {
            do resp.%DispatchSetProperty($LISTGET(parts, level), classes.Data("Hidden"))
        }
        set lastParts = parts
        for i=1:1:$LISTLENGTH(lastParts)-1 {
            set $LIST(lastParts, i) = "/"_$LISTGET(lastParts, i)
        }
    }

    quit objects.GetAt(1)
]]></Implementation>
</Method>

<Method name="fillClassData">
<Description>
Return structured data about class.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>oData:%ZEN.proxyObject,className:%String,level:%String="",currLevel:%Integer=0</FormalSpec>
<Private>1</Private>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
    if ((level'="") && (+currLevel>+level)) { quit "" }
    set currLevel = $increment(currLevel)
    set classDefinition = ##class(%Dictionary.ClassDefinition).%OpenId(className)
    set compiledClassDefinition = ##class(%Dictionary.CompiledClass).%OpenId(className)
    if (classDefinition = "") || (oData.classes.%DispatchGetProperty(classDefinition.Name) '= "") quit ""

    set oClass = ##class(%ZEN.proxyObject).%New()
    do oData.classes.%DispatchSetProperty(classDefinition.Name, oClass) // prevent from recursive setup
    set package = $LISTTOSTRING($LIST($LISTFROMSTRING(classDefinition.Name, "."), 1, *-1),".")
    set oProperties = ##class(%ZEN.proxyObject).%New()
    set oQueries = ##class(%ZEN.proxyObject).%New()
    set oIndices = ##class(%ZEN.proxyObject).%New()
    set oXDatas = ##class(%ZEN.proxyObject).%New()

    set oClass.isDataType = classDefinition.ClientDataTypeIsDefined()
    set oClass.isOdbcType = classDefinition.OdbcTypeIsDefined()
    set oClass.isSoapBindingStyle = classDefinition.SoapBindingStyleIsDefined()
    set oClass.isSoapBodyUse = classDefinition.SoapBodyUseIsDefined()
    set oClass.isSqlCategory = classDefinition.SqlCategoryIsDefined()

    set props = ##class(%Dictionary.ClassDefinition).%OpenId("%Dictionary.ClassDefinition")
    for j=1:1:props.Properties.Count() {
        set pname = props.Properties.GetAt(j).Name
        set:((pname '= "parent")
             && ('props.Properties.GetAt(j).Private)
             && ('$IsObject($PROPERTY(classDefinition, pname)))) $PROPERTY(oClass, pname) = $PROPERTY(classDefinition, pname)
    }
    if (oClass.TimeChanged) { set oClass.TimeChanged = $zdatetime(oClass.TimeChanged) }
    if (oClass.TimeCreated) { set oClass.TimeCreated = $zdatetime(oClass.TimeCreated) }
    if ((compiledClassDefinition '= "") && (compiledClassDefinition.ClassType '= "")) {
        set oClass.ClassType = compiledClassDefinition.ClassType // set class type from all inherited classes
    }

    set oClass.Super = "" // do not quit with super at this moment
    if (oData.restrictPackage) && ('..inPackage(oData.basePackageName, package)) quit oClass
    set oClass.Super = ..correctInheritance(oData, classDefinition, package) // now expand super names

    set oClass.properties = oProperties
    set count = classDefinition.Properties.Count()
    set props = ##class(%Dictionary.ClassDefinition).%OpenId("%Dictionary.PropertyDefinition")
    for i=1:1:count {
        set oProp = ##class(%ZEN.proxyObject).%New()
        set p = classDefinition.Properties.GetAt(i)
        do oProperties.%DispatchSetProperty(p.Name, oProp)
        for j=1:1:props.Properties.Count() {
            set pname = props.Properties.GetAt(j).Name
            set:(pname '= "parent") $PROPERTY(oProp, pname) = $PROPERTY(p, pname)
        }
        if (..classExists(package _ "." _ p.Type)) {
            set oProp.Type = package _ "." _ p.Type
            do ..fillClassData(oData, package _ "." _ p.Type, level, currLevel)
        } elseif (..classExists(..extendClassFromType(p.Type))) {
            set oProp.Type = ..extendClassFromType(p.Type)
            do ..fillClassData(oData, ..extendClassFromType(p.Type), level, currLevel)
        }  else {
            set oProp.Type = ..extendClassFromType(p.Type)
        }
    }

    set oMethods = ##class(%ZEN.proxyObject).%New()
    set oClass.methods = oMethods
    set count = classDefinition.Methods.Count()
    set props = ##class(%Dictionary.ClassDefinition).%OpenId("%Dictionary.MethodDefinition")
    for i=1:1:count {
        set oMeth = ##class(%ZEN.proxyObject).%New()
        set met = classDefinition.Methods.GetAt(i)
        do oMethods.%DispatchSetProperty(met.Name, oMeth)
        for j=1:1:props.Properties.Count() {
            set pname = props.Properties.GetAt(j).Name
            set:((pname '= "parent") && (pname '= "Implementation")) $PROPERTY(oMeth, pname) = $PROPERTY(met, pname)
        }
    }

    set oParameters = ##class(%ZEN.proxyObject).%New()
    set oClass.parameters = oParameters
    set count = classDefinition.Parameters.Count()
    set props = ##class(%Dictionary.ClassDefinition).%OpenId("%Dictionary.ParameterDefinition")
    for i=1:1:count {
        set oPar = ##class(%ZEN.proxyObject).%New()
        set p = classDefinition.Parameters.GetAt(i)
        for j=1:1:props.Properties.Count() {
            set pname = props.Properties.GetAt(j).Name
            set:(pname '= "parent") $PROPERTY(oPar, pname) = $PROPERTY(p, pname)
        }
        do oParameters.%DispatchSetProperty(p.Name, oPar)
    }

    #dim q as %Dictionary.QueryDefinition
    set oClass.queries = oQueries
    set props = ##class(%Dictionary.ClassDefinition).%OpenId("%Dictionary.QueryDefinition")
    for i=1:1:classDefinition.Queries.Count() {
        set oProp = ##class(%ZEN.proxyObject).%New()
        set q = classDefinition.Queries.GetAt(i)
        for j=1:1:props.Properties.Count() {
            set pname = props.Properties.GetAt(j).Name
            set:(pname '= "parent") $PROPERTY(oProp, pname) = $PROPERTY(q, pname)
        }
        do oQueries.%DispatchSetProperty(q.Name, oProp)
    }

    #dim xd as %Dictionary.XDataDefinition
    set oClass.xdatas = oXDatas
    set props = ##class(%Dictionary.ClassDefinition).%OpenId("%Dictionary.XDataDefinition")
    for i=1:1:classDefinition.XDatas.Count() {
        set oProp = ##class(%ZEN.proxyObject).%New()
        set xd = classDefinition.XDatas.GetAt(i)
        for j=1:1:props.Properties.Count() {
            set pname = props.Properties.GetAt(j).Name
            set:((pname '= "parent") && (pname '= "Object")) $PROPERTY(oProp, pname) = $PROPERTY(xd, pname)
        }
        do oXDatas.%DispatchSetProperty(xd.Name, oProp)
    }

    #dim ind as %Dictionary.IndexDefinition
    set oClass.indices = oIndices
    set props = ##class(%Dictionary.ClassDefinition).%OpenId("%Dictionary.IndexDefinition")
    for i=1:1:classDefinition.Indices.Count() {
        set oProp = ##class(%ZEN.proxyObject).%New()
        set ind = classDefinition.Indices.GetAt(i)
        for j=1:1:props.Properties.Count() {
            set pname = props.Properties.GetAt(j).Name
            set:(pname '= "parent") $PROPERTY(oProp, pname) = $PROPERTY(ind, pname)
        }
        do oIndices.%DispatchSetProperty(ind.Name, oProp)
    }

    do ..collectInheritance(oData, oClass.Super, level, currLevel)

    quit oClass
]]></Implementation>
</Method>

<Method name="getMethod">
<Description>
Return method data.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,methodName:%String,namespace:%String</FormalSpec>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
    zn:$GET(namespace)'="" namespace
    set oMeth = ##class(%ZEN.proxyObject).%New()
    set met = ##class(%Dictionary.MethodDefinition).%OpenId(className _ "||" _ methodName)
    if (met = "") { set oMeth.error = 1 quit oMeth }

    set oMeth.description = met.Description
    set oMeth.arguments = met.FormalSpec
    set oMeth.returns = met.ReturnType
    set oMeth.code = ""
    do {
        set chars = met.Implementation.Read()
        set oMeth.code = oMeth.code _ chars
    } while (chars)

    quit oMeth
]]></Implementation>
</Method>

<Method name="inPackage">
<Description><![CDATA[
Returns if <var>packageName</var> is in <var>basePackageName</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>basePackageNames:%String,packageName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set pack = $PIECE(packageName, ".", 1)
	set list = $LISTFROMSTRING(basePackageNames, ",")
	set OK = 0
	for i=1:1:$LISTLENGTH(list) {
		if ($LISTGET(list, i) = pack) {
			set OK = 1
			quit
		}
	}
    quit OK
]]></Implementation>
</Method>

<Method name="extendClassFromType">
<Description>
Wrap registered types to class names</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>typeName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    return $CASE(typeName,
        "%Boolean": "%Library.Boolean",
        "%String": "%Library.String",
        "%Integer": "%Library.Integer",
        "%DataType": "%Library.DataType",
        "%Status": "%Library.Status",
        "%CacheString": "%Library.CacheString",
        "%Persistent": "%Library.Persistent",
        :typeName)
]]></Implementation>
</Method>

<Method name="correctInheritance">
<Description>
Return extended inheritance names</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>oData:%ZEN.proxyObject,baseClassDefinition:%Dictionary.ClassDefinition,basePack:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    set superParts = $LISTFROMSTRING(baseClassDefinition.Super, ",")
    for i=1:1:$LISTLENGTH(superParts) {
        set className = $LISTGET(superParts, i)

        // try to find class with base package, if not successfull - try to add class as it is
        if (..classExists(basePack_"."_className)) {
            set clsName = basePack_"."_className
        } else {
            set clsName = ..extendClassFromType(className)
        }

        set $LIST(superParts, i) = clsName
    }
    quit $LISTTOSTRING(superParts)
]]></Implementation>
</Method>

<Method name="collectInheritance">
<Description>
Fill inheritance data
Returns new (correct) super</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>oData:%ZEN.proxyObject,super:%String,level:%String="",currLevel:%Integer=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set superParts = $LISTFROMSTRING(super, ",")
    for i=1:1:$LISTLENGTH(superParts) {
        do ..fillClassData(oData, $LISTGET(superParts, i), level, currLevel)
    }
    quit $$$OK
]]></Implementation>
</Method>

<Method name="getBaseOData">
<Description>
Setup basic output data object</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>packageName:%String,baseNamespace:%String,savedName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
    set oData = ##class(%ZEN.proxyObject).%New()
    set oData.basePackageName = packageName
    set oData.restrictPackage = 1 // expand classes only in base package
    set oData.classes = ##class(%ZEN.proxyObject).%New()

    set ns = $namespace
    zn baseNamespace
    if $get(^ClassExplorer("savedView", ns_":"_savedName)) '= "" {
        set oData.savedView = $get(^ClassExplorer("savedView", ns_":"_savedName))
    }
    zn ns

    quit oData
]]></Implementation>
</Method>

<Method name="classExists">
<Description>
Returns if class with given name exists.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    quit ##class(%Dictionary.ClassDefinition).%OpenId(className) '= ""
]]></Implementation>
</Method>

<Method name="getPackageView">
<Description>
Returns structured package data</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>rootPackageName:%String,namespace:%String</FormalSpec>
<ReturnType>%ZEN.proxyObject</ReturnType>
<Implementation><![CDATA[
    set baseNamespace = $namespace
    zn:$GET(namespace)'="" namespace
    set oData = ..getBaseOData(rootPackageName, baseNamespace, "PACKAGE:"_rootPackageName)
    set classes = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:Summary")
    do classes.Execute()
    set listLen = $LISTLENGTH($LISTFROMSTRING(rootPackageName, ".")) // bottom level of package to extract

    while (classes.Next()) {
        set className = classes.Data("Name")
        set packageName = $LISTTOSTRING($LIST($LISTFROMSTRING(className, "."), 1, listLen), ".")
        if (packageName = rootPackageName) {
            do ..fillClassData(oData, className)
        }
    }

    quit oData
]]></Implementation>
</Method>

<Method name="getArbitraryView">
<ClassMethod>1</ClassMethod>
<FormalSpec>classList:%String,namespace:%String,level:%String=""</FormalSpec>
<Implementation><![CDATA[
	set baseNamespace = $namespace
    zn:$GET(namespace)'="" namespace
    set list = $LISTFROMSTRING(classList, ",")

    set basePackages = $LB()
    set count = 0
    for i=1:1:$LISTLENGTH(list) {
	    set packName = $PIECE($LISTGET(list, i), ".", 1)
	    if ($LISTFIND(basePackages, packName) = 0) {
		    set $LIST(basePackages, count + 1) = packName
		    set count = count + 1
	    }
    }

    set oData = ..getBaseOData($LISTTOSTRING(basePackages, ",", 1), baseNamespace, "ARBITRARY:"_classList)

    for i=1:1:$LISTLENGTH(list) {
		do ..fillClassData(oData, $LISTGET(list, i), level)
    }

    quit oData
]]></Implementation>
</Method>
</Class>
</Export>
